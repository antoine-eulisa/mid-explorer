<!DOCTYPE html>
<meta charset="utf-8">
<style>

rect {
  fill: none;
  pointer-events: all;
}

.node {
  fill: #000;
}

.event.quarantined {
  stroke: black;
  stroke-width: 3px;
}

.id.quarantined.notopen {
  stroke: red;
}

.id.quarantined {
  stroke: black;
  stroke-width: 2px;
}
.event.ees{ fill: red; }
.event.vis{ fill: green; }
.id{    fill: blue; }



.person {
  fill:  #99ccff;
  stroke: #00F;
  stroke-width: 1px;
}

.traveller {
  fill: #ce5893;
  stroke: #F00;
  stroke-width: 1px;
}

.dossier {
  fill: #58ce93;
  stroke: #0F0;
  stroke-width: 1px;
}


.matched{
  fill: red;
}


.cursor {
  fill: none;
  stroke: brown;
  pointer-events: none;
}

.link {
  stroke: #999;
}

.link.match {
  stroke-dasharray: 0,2 1;
}

text {
  font: 20px arial;
  pointer-events: none;
  fill:black;
  //text-shadow: 0 1px 0 #000, 1px 0 0 #000, 0 -1px 0 #000, -1px 0 0 #000;
}

      div#container {
 width:960px;
 margin:0 auto;
}


</style>
<body>
<!--
<script src="d3.v3.min.js"></script>
-->
  <div id='container'>
  <div id='title'></div>
  <div id='step'></div>
</div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 960,
    height = 500;

var fill = d3.scale.category20();

var force = d3.layout.force()
    .size([width, height])
    .nodes([]) // initialize empty 
    .linkDistance(60)
    .chargeDistance(200)
    .charge(-100)
    .gravity(0.01)
    .on("tick", tick);

var svg = d3.select("#title").append("svg")
    .attr("stroke", 'grey')
    .attr("stroke-width", '1px')
    .attr("width", width)
    .attr("height", height);
    //.on("mousemove", mousemove)
  //  .on("mousedown", mousedown_droppoint);

    //Define the arrows symbol
//		svg.append("svg:defs").selectAll("marker")
//			.data(["end"])
//			.enter().append("svg:marker")    
//			.attr("id", String)
//			.attr("viewBox", "0 -5 10 10")
//			.attr("refX", 15)
//			.attr("fill", "#999")
//			.attr("refY", 0)
//			.attr("markerWidth", 10)
//			.attr("markerHeight", 10)
//			.attr("orient", "auto")
//			.append("svg:path")
//			.attr("d", "M0,-5L10,0L0,5");

svg.append("rect")
    .attr("width", width)
    .attr("height", height);

var nodes = force.nodes(),
    links = force.links(),
    node = svg.selectAll(".node"),
    link = svg.selectAll(".link");

//var cursor = svg.append("circle") .attr("r", 30) .attr("transform", "translate(-100,-100)") .attr("class", "cursor");

function restart() {
  link = link.data(links);

  link.enter().insert("line", ".node")
    .attr("class", function(d) {
      if (d.target.type === 'id' && d.source.type === 'id') {
        return "link match";
      } else {
        return "link";
      }
    })
  .attr("marker-end", function(d) {
    //console.log(d);
    if (d.target.type !='person') {
      return "url(#end)";
    } else {
      return null;
    }
  });

  node = node.data(nodes);

  node.enter().insert("circle")
    .attr("class", function( d ) { 
      return d.type+' '+d.position;
    })
    .attr("r", function(d) {
      if (d.type === 'event') {
        return 10;
      } else if (d.type === 'id') {
        return 5;
      } else if (d.type.includes('person')) {
        return 15;
      }else {
		return 2;
	  }
    })
    .call(force.drag);

    //Add the SVG Text Element to the svgContainer
    var text = svg.selectAll("text")
      .data(nodes)
      .enter()
      .append("text")
      .text( function (d) { 
        if (d.type.includes('person')) {
          return d.name; 
        }
      });



  force.start();
}

restart();

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("class", function( d ) { 
        if (isIn(inquarantine, d.name)) {
			if (isIn(notopen, d.name)) {
			  return d.type+' '+d.position+' quarantined notopen';
			}else {
			  return d.type+' '+d.position+' quarantined';
			}
        } else {
          return d.type+' '+d.position;
        }
      });

  svg.selectAll("text").attr("transform", transform);

  
}

function transform(d) {
  return "translate(" + (d.x-20) + "," + (d.y+35) + ")";
}

/*
function mousemove() {
  cursor.attr("transform", "translate(" + d3.mouse(this) + ")");
}
*/

allnodes = {};

inquarantine = {};

notopen = {};

function addNode(name, type, position) {
  if (allnodes.hasOwnProperty(name)) {
    console.log('script error, node '+name+' already exists');
    return allnodes[name];
  } else {
    
    var nodeData = {x:xOf(type), y:yOf(type), name:name, type:type, position:position};
    nodes.push(nodeData);
    allnodes[name] = nodeData;
    return nodeData;
  }
}

function removeNode(name) {
  if (!allnodes.hasOwnProperty(name)) {
    console.log('script error, node '+name+' not found');
  } else {
    nodes.splice( nodes.indexOf(allnodes[name]), 1 );
  }
}

function xOf(type) {
  if (type.includes('person')) {
    return width/2
  } else {
    return 100 + Math.random()*20;
  }
}

function yOf(type) {
  if (type.includes('person')) {
    return height/2
  } else {
    return 100 + Math.random()*20;
  }
}

function linkNodes(source, target) {
  if (!(typeof source === 'undefined' || typeof target === 'undefined')) {
    links.push({
      source: source, 
      target: target});
  }
}

function entersQuarantine(eventName) {
  inquarantine[eventName] = true;
}

function exitQuarantine(eventName) {
  inquarantine[eventName] = false;
}

function notAvailable(eventName) {
  notopen[eventName] = true;
}

function nowAvailable(eventName) {
  notopen[eventName] = false;
}

function isIn(array, eventName) {
  return array.hasOwnProperty(eventName) && array[eventName];
}

//#### state of the finite state machine

function stepInfo(stepInfo) {
console.log('one EES event');
  document.getElementById('step').innerHTML = stepInfo;
}

var steps = [ 
  function () {
    stepInfo('EES event');
    linkNodes(
        addNode('e1', 'event', 'ees'),
        addNode('i1', 'id', 'ees'));
  }, function () {
	stepInfo('no match found in EES, traveller file created');
    linkNodes(
        allnodes['e1'],
        addNode('TFx', 'person traveller', ''));
  }, function () {
    stepInfo('no matches found during MID, individual file created');
    linkNodes(
        allnodes['i1'],
        addNode('IF1', 'person', ''));
//  }, function () {
//	stepInfo('new EES event');
//    linkNodes(
//        addNode('e2', 'event', 'ees'),
//        addNode('i2', 'id', 'ees'));
//  }, function () {
//	stepInfo('matches found in EES, traveller file updated');
//    linkNodes(
//        allnodes['e2'],
//        allnodes['TFx']);
//  }, function () {
//	stepInfo('matches provided to CIR, no matches in MID, individual file updated');
//	   linkNodes(
//        allnodes['i2'],
//        allnodes['i1']);
//    linkNodes(
//        allnodes['i2'],
//        allnodes['IF1']);
  },function () {
    stepInfo('same situation in another system');
    linkNodes(
        addNode('ev1', 'event', 'vis'),
        addNode('iv1', 'id', 'ees'));
    linkNodes(
        allnodes['ev1'],
        addNode('Dx', 'person dossier', ''));
    linkNodes(
        allnodes['iv1'],
        addNode('IF2', 'person', ''));
    linkNodes(
        addNode('ev2', 'event', 'vis'),
        addNode('iv2', 'id', 'vis'));
    linkNodes(
        allnodes['ev2'],
        allnodes['Dx']);
//	linkNodes(
//        allnodes['iv2'],
//        allnodes['iv1']);
     linkNodes(
        allnodes['iv2'],
        allnodes['IF2']);
		//we add another event to EES matching this 
	linkNodes(
        addNode('ee2', 'event', 'ees'),
        addNode('ie2', 'id', 'ees'));
    linkNodes(
        allnodes['ee2'],
        addNode('TFy', 'person traveller', ''));
	linkNodes(
        allnodes['ie2'],
        allnodes['iv1']);
    linkNodes(
        allnodes['ie2'],
        allnodes['IF2']);
  }, 
  function () {
    stepInfo('new EES event');
    linkNodes(
        addNode('ee1', 'event', 'ees'),
        addNode('ie1', 'id', 'ees'));
  }, function () {
	stepInfo('match found in EES, traveller file updated');
    linkNodes(
        allnodes['ee1'],
        allnodes['TFx']);
  }, function () {
    stepInfo('matches provided to CIR, individual file updated');
//	linkNodes(
//        allnodes['ie1'],
//        allnodes['i1']);

    linkNodes(
        allnodes['ie1'],
        allnodes['IF1']);
  }, function () {
    stepInfo('matches with identities belonging to IF2 found in MID . What about IF1/IF2? What about the TFx/TFy? <p>Proposal<ul><li>EES could resolve the incoherence by merging the two TF, informing the CIR that the identities of the source TF should be added to the IF referenced by the target TF</li><li>Then a MID officer could decide that the links between the EES identity and VIS identity is valid and the two IF can be merged</li></ul></p> ');
    linkNodes(
        allnodes['ie1'],
        allnodes['iv1']);
	linkNodes(
        allnodes['ie1'],
        allnodes['IF2']);
  }, function () {
    stepInfo('EES resolve the incoherence by merging the two TF, informing the CIR that the identities of the source TF should be added to the IF referenced by the target TF ');
	removeNode('TFy');

  }
];

function no_more_event() {
  return no_more_event;
}

//starting the state_machine

var step= 0;

function advanceFsm() {
  
  if (step<steps.length) {
    steps[step++]();
  }

  restart();
}

document.addEventListener('keydown', function(event) {
				if (event.keyCode == 32) {
				  advanceFsm();
				}
    }, false);
/*
function mousedown() {
  var point = d3.mouse(this),
      node = {x: point[0], y: point[1]},
      n = nodes.push(node);

  // add links to any nearby nodes
  nodes.forEach(function(target) {
    var x = target.x - node.x,
        y = target.y - node.y;
    if (Math.sqrt(x * x + y * y) < 30) {
      links.push({source: node, target: target});
    }
  });

  restart();
}
*/


</script>
